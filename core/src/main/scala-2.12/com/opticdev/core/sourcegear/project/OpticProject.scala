package com.opticdev.core.sourcegear.project

import java.nio.file.{StandardWatchEventKinds => EventType}

import akka.actor.ActorRef
import akka.pattern.ask
import akka.util.Timeout
import better.files.FileWatcher._
import better.files.{File, _}
import com.opticdev.core.actorSystem
import com.opticdev.core.sourcegear.project.status._
import com.opticdev.core.sourcegear.SourceGear
import com.opticdev.core.sourcegear.actors.ActorCluster
import com.opticdev.core.sourcegear.graph.{ProjectGraph, ProjectGraphWrapper}
import com.opticdev.core.sourcegear.project.config.ProjectFile
import com.opticdev.core.sourcegear.project.monitoring.{FileStateMonitor, ShouldWatch}
import com.opticdev.core.sourcegear.project.status.ProjectStatus
import com.opticdev.core.sourcegear.snapshot.Snapshot
import com.opticdev.core.sourcegear.storage.ProjectRuntimeObjectStorage
import com.opticdev.core.sourcegear.sync.{DiffSyncGraph, SyncPatch}
import com.opticdev.runtime.RuntimeManager
import net.jcazevedo.moultingyaml.YamlString

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.{Await, Future, Promise}
import scala.concurrent.duration._
import scala.util.{Failure, Success}

abstract class OpticProject(val name: String, val baseDirectory: File)(implicit val actorCluster: ActorCluster) extends ProjectBase {

  import com.opticdev.core.sourcegear.actors._

  /* Project Actor setup */

  val projectActor: ActorRef = actorCluster.newProjectActor()(project = this)

  /* Private & public declarations of the project status & info */

  protected val projectStatusInstance: ProjectStatus = new ProjectStatus()
  val projectStatus: ImmutableProjectStatus = projectStatusInstance.immutable
  def projectInfo : ProjectInfo = ProjectInfo(name, baseDirectory.pathAsString, projectStatus)

  /* Normal Disk Monitoring */

  val watcher: ActorRef = baseDirectory.newWatcher(recursive = true)

  def projectFileChanged(newPf: ProjectFile) : Unit = {
    projectStatusInstance.touch
    if (newPf.interface.isSuccess) {
      projectStatusInstance.configStatus = ValidConfig
    } else {
      projectStatusInstance.configStatus = InvalidConfig(newPf.interface.errors.mkString("\n"))
    }
  }

  val projectFile = new ProjectFile(baseDirectory / "optic.yml", onChanged = projectFileChanged)

  def projectSourcegear : SourceGear

  def onSourcegearChanged(callback: (SourceGear)=> Unit) : Unit = Unit

  def regenerateSourceGear(newPf: ProjectFile) : Unit = Unit

  def watch = {
    rereadAll
    watcher ! when(events = EventType.ENTRY_CREATE, EventType.ENTRY_MODIFY, EventType.ENTRY_DELETE)(handleFileChange)
    projectStatusInstance.monitoringStatus = Watching
  }

  def fullRefresh = {
    regenerateSourceGear(projectFile)
    rereadAll
  }

  var lastSGHash = ""


  private var _loadingProjectPromise = Promise[Unit]()
  private var _firstPassCompletePromise = Promise[Unit]()
  private var _firstPassCompleteFuture = Future.sequence(Seq(_loadingProjectPromise.future, _firstPassCompletePromise.future))
  def onFirstPassComplete = _firstPassCompleteFuture

  def rereadAll = {
    implicit val timeout: akka.util.Timeout = Timeout(5 minutes)
    implicit val sourceGear = projectSourcegear

    if (sourceGear.configHash != lastSGHash && !sourceGear.isEmpty) {

      (if (!_loadingProjectPromise.isCompleted) _loadingProjectPromise.success(Unit))

      //should delete all
      ProjectActorSyncAccess.clearGraph(projectActor)
      ProjectActorSyncAccess.addConnectedProjectSubGraphs(projectActor, sourceGear.connectedProjectGraphs)
      ProjectRuntimeObjectStorage
        .loadFromStorageAsObjectNodes(name)
        .foreach(ProjectActorSyncAccess.addConnectedAddRuntimeObjects(projectActor, _))
      ParseSupervisorSyncAccess.clearCache()

      lastSGHash = sourceGear.configHash

      projectStatusInstance.firstPassStatus = InProgress

      val futures = filesToWatch.toSeq.map(i => projectActor ? FileCreated(i, this))

      Future.sequence(futures).onComplete(i => {
        projectStatusInstance.firstPassStatus = Complete
        (if (!_firstPassCompletePromise.isCompleted) _firstPassCompletePromise.success(Unit))
        projectStatusInstance.touch
      })

    }
  }

  val handleFileChange : better.files.FileWatcher.Callback = {
    case (EventType.ENTRY_CREATE, file) => {
      implicit val sourceGear = projectSourcegear
      projectStatusInstance.touch
      filesStateMonitor.markUpdated(file)
      if (shouldWatchFile(file)) projectActor ! FileCreated(file, this)
    }
    case (EventType.ENTRY_MODIFY, file) => {
      if (!RuntimeManager.isCollecting) { //we don't want to accident process our temporary changes
        implicit val sourceGear = projectSourcegear
        projectStatusInstance.touch
        filesStateMonitor.markUpdated(file)
        if (projectFile.fileUpdateTriggersReload(file)) {
          projectFile.reload
        } else {
          if (shouldWatchFile(file)) projectActor ! FileUpdated(file, this)
        }
      }
    }
    case (EventType.ENTRY_DELETE, file) => {
      implicit val sourceGear = projectSourcegear
      filesStateMonitor.markUpdated(file)
      projectStatusInstance.touch
      if (shouldWatchFile(file)) projectActor ! FileDeleted(file, this)
    }
  }

  def stopWatching = {
    actorSystem.stop(watcher)
    projectStatusInstance.monitoringStatus = NotWatching
  }

  def projectGraph: ProjectGraph = {
    implicit val timeout = Timeout(15 seconds)
    val future = projectActor ? CurrentGraph
    Await.result(future, timeout.duration).asInstanceOf[ProjectGraphWrapper].projectGraph
  }

  def projectGraphWrapper: ProjectGraphWrapper = {
    implicit val timeout = Timeout(15 seconds)
    val future = projectActor ? CurrentGraph
    Await.result(future, timeout.duration).asInstanceOf[ProjectGraphWrapper]
  }

  /* Staged File Monitor */
  val filesStateMonitor : FileStateMonitor = new FileStateMonitor()
  def stageFileContents(file: File, contents: String, fromContextQuery: Boolean = false): Future[Any] = {
    implicit val timeout: akka.util.Timeout = Timeout(10 seconds)
    filesStateMonitor.stageContents(file, contents)
    projectActor ? FileUpdatedInMemory(file, contents, this, fromContextQuery)(projectSourcegear)
  }

  /* Control logic for watching files */
  //@todo profile this. Seems liable to cause big slowdowns with many files running through it
  def shouldWatchFile(file: File) : Boolean = {
    if (projectSourcegear.isEmpty) return false
    ShouldWatch.file(file,
      projectSourcegear.validExtensions,
      projectFile.interface.primary.exclude.getOrElse(List()).map(i => File(baseDirectory.pathAsString +"/"+ i)) ++ projectSourcegear.excludedPaths.map(i => File(i)))
  }

  def filesToWatch : Set[File] = baseDirectory.listRecursively.toVector.filter(shouldWatchFile).toSet

  def snapshot(withAstGraph: Boolean = false): Future[Snapshot] = {
    implicit val timeout: akka.util.Timeout = Timeout(1 minute)
    (projectActor ? GetSnapshot(projectSourcegear, withAstGraph, this)).mapTo[Future[Snapshot]].flatten
  }

  def syncPatch: Future[SyncPatch] = {
    implicit val timeout: akka.util.Timeout = Timeout(1 minute)
    snapshot(false).map(snapshot=> DiffSyncGraph.calculateDiff(snapshot)(this))
  }

}
